package io.arcblock.walletkit.solana

import com.google.common.io.BaseEncoding
import org.bitcoinj.crypto.DeterministicHierarchy
import org.bitcoinj.crypto.HDKeyDerivation
import org.bitcoinj.crypto.HDUtils
import org.bitcoinj.crypto.MnemonicCode

sealed class DerivationPath(val path: String) {
  object DEPRECATED_M_501H_0H_0_0 : DerivationPath("M/501H/0H/0/0")
  object BIP44_M_44H_501H_0H : DerivationPath("M/44H/501H/0H")
  object BIP44_M_44H_501H_0H_OH : DerivationPath("M/44H/501H/0H/0H")

}

class Account {
  private var keyPair: TweetNaclFast.Signature.KeyPair

  constructor() {
    keyPair = TweetNaclFast.Signature.keyPair()
  }

  constructor(secretKey: ByteArray) {
    keyPair = TweetNaclFast.Signature.keyPair_fromSecretKey(secretKey)
  }

  constructor(keyPair: TweetNaclFast.Signature.KeyPair) {
    this.keyPair = keyPair
  }

  val publicKey: PublicKey
    get() = PublicKey(keyPair.publicKey)
  val secretKey: ByteArray
    get() = keyPair.secretKey

  companion object {
    /**
     * Derive a Solana account from a Mnemonic generated by the Solana CLI using bip44 Mnemonic with deviation path of
     * m/55H/501H/0H
     * @param words seed words
     * @param passphrase seed passphrase
     * @return Solana account
     */
    private fun fromBip44Mnemonic(
      words: List<String>,
      passphrase: String
    ): Account {
      val solanaBip44 = SolanaBip44()
      val seed = MnemonicCode.toSeed(words, passphrase)
      val privateKey = solanaBip44.getPrivateKeyFromSeed(seed, DerivableType.BIP44)
      return Account(TweetNaclFast.Signature.keyPair_fromSeed(privateKey))
    }

    /**
     * Derive a Solana account from a Mnemonic generated by the Solana CLI using bip44 Mnemonic with deviation path of
     * m/55H/501H/0H/0H
     * @param words seed words
     * @param passphrase seed passphrase
     * @return Solana account
     */
    private fun fromBip44MnemonicWithChange(
      words: List<String>,
      passphrase: String
    ): Account {
      val solanaBip44 = SolanaBip44()
      val seed = MnemonicCode.toSeed(words, passphrase)
      val privateKey = solanaBip44.getPrivateKeyFromSeed(seed, DerivableType.BIP44CHANGE)
      println("account privateKey =>${BaseEncoding.base16().encode(privateKey)}")
      return Account(TweetNaclFast.Signature.keyPair_fromSeed(privateKey))
    }

    private fun fromDeprecatedMnemonic(
      words: List<String>,
      passphrase: String
    ): Account {
      val seed = MnemonicCode.toSeed(words, passphrase)
      val masterPrivateKey = HDKeyDerivation.createMasterPrivateKey(seed)
      val deterministicHierarchy = DeterministicHierarchy(masterPrivateKey)
      val child =
        deterministicHierarchy[HDUtils.parsePath(DerivationPath.DEPRECATED_M_501H_0H_0_0.path), true, true]
      val keyPair = TweetNaclFast.Signature.keyPair_fromSeed(child.privKeyBytes)
      return Account(keyPair)
    }

    fun fromMnemonic(
      words: List<String>,
      passphrase: String,
      derivationPath: DerivationPath = DerivationPath.BIP44_M_44H_501H_0H_OH
    ): Account {
      return when (derivationPath) {
        is DerivationPath.DEPRECATED_M_501H_0H_0_0 -> fromDeprecatedMnemonic(words, passphrase)
        is DerivationPath.BIP44_M_44H_501H_0H -> fromBip44Mnemonic(words, passphrase)
        is DerivationPath.BIP44_M_44H_501H_0H_OH -> fromBip44MnemonicWithChange(words, passphrase)
      }
    }
  }
}